import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import SignalList, { calcScore, TrafficLight } from './SignalList';
// Note: The styles import will not work directly in jest environment as CSS modules are not processed by default.
// We will check for class names like 'red', 'amber', 'green' assuming they are applied alongside hashed class names.
// For a more robust solution, Jest needs to be configured to handle CSS modules (e.g., using identity-obj-proxy).

// Helper to get the icon slider div for a specific list item
const getIconSlider = (listItem: HTMLElement) => {
  // The actual class name for iconSlider will be generated by CSS modules, e.g., "SignalList_iconSlider__XXXXX"
  // We search for a div that *contains* "iconSlider" in its class list.
  // This is a bit fragile. A data-testid attribute would be more robust.
  const slider = listItem.querySelector<HTMLDivElement>('div[class*="iconSlider"]');
  if (!slider) {
    throw new Error('Icon slider element not found. Check CSS module class name or add a data-testid.');
  }
  return slider;
};


describe('SignalList', () => {
  const mockTitle = 'Test Title';
  const mockDescription = 'Test Description';
  // Default initial state for all items is 'amber' as per component logic
  // nextState cycles: 'amber' -> 'green' -> 'red' -> 'amber'

  it('renders the correct number of items and initial visual states', () => {
    const mockItems = ['item1', 'item2', 'item3'];
    const mockOnScoreChange = jest.fn();

    render(
      <SignalList
        items={mockItems}
        onScoreChange={mockOnScoreChange}
        title={mockTitle}
        description={mockDescription}
      />
    );

    const renderedItems = screen.getAllByRole('listitem');
    expect(renderedItems.length).toBe(mockItems.length);

    // Check initial visual state (all should be amber)
    renderedItems.forEach(item => {
      const iconSlider = getIconSlider(item);
      // We check for the state class e.g. styles.amber. Since we can't resolve styles.amber,
      // we check if one of the classnames *is* 'amber'. This assumes SignalList.tsx adds 'amber', 'green', 'red' directly.
      // From SignalList.tsx: className={`${styles.iconSlider} ${styles[current]}`}
      // This means the class will be something like "SignalList_iconSlider__HASH SignalList_amber__HASH"
      // A better way is to check for a class that ends with 'amber', or use data attributes.
      // For now, we assume `styles.amber` might resolve to just 'amber' or be part of a more complex name.
      // Let's check if *any* class on iconSlider is 'amber' or contains 'amber'.
      // This is not ideal. The component should ideally add a data-state attribute.
      expect(iconSlider.classList.toString()).toMatch(/amber/i);
    });
    // Initial score (all amber)
    const initialExpectedScore = calcScore(Array(mockItems.length).fill('amber'));
    expect(mockOnScoreChange).toHaveBeenCalledWith(initialExpectedScore);
  });

  it('updates item state on click, calls onScoreChange, and reflects visual changes', () => {
    const mockItems = ['item A', 'item B'];
    const mockOnScoreChange = jest.fn();

    // Initial states are 'amber', 'amber'
    // Initial score: calcScore(['amber', 'amber']) which is (50+50)/2 = 50
    const initialExpectedScore = calcScore(['amber', 'amber']);

    const { rerender } = render(
      <SignalList
        items={mockItems}
        onScoreChange={mockOnScoreChange}
        title={mockTitle}
        description={mockDescription}
      />
    );
    // useEffect in SignalList calls onScoreChange on mount
    expect(mockOnScoreChange).toHaveBeenCalledWith(initialExpectedScore);

    const listItems = screen.getAllByRole('listitem');
    expect(listItems.length).toBe(mockItems.length);

    let iconSliderA = getIconSlider(listItems[0]);
    let iconSliderB = getIconSlider(listItems[1]);

    // Initial visual state check
    expect(iconSliderA.classList.toString()).toMatch(/amber/i);
    expect(iconSliderB.classList.toString()).toMatch(/amber/i);

    // 1. Click item A: 'amber' -> 'green'. States: ['green', 'amber']
    fireEvent.click(listItems[0]);
    let expectedStates: TrafficLight[] = ['green', 'amber'];
    let expectedScore = calcScore(expectedStates); // (100+50)/2 = 75
    expect(mockOnScoreChange).toHaveBeenCalledWith(expectedScore);
    iconSliderA = getIconSlider(listItems[0]); // Re-query after click might be safer if component re-renders deeply
    expect(iconSliderA.classList.toString()).toMatch(/green/i);
    expect(iconSliderA.classList.toString()).not.toMatch(/amber|red/i);

    // 2. Click item A again: 'green' -> 'red'. States: ['red', 'amber']
    fireEvent.click(listItems[0]);
    expectedStates = ['red', 'amber'];
    expectedScore = calcScore(expectedStates); // (0+50)/2 = 25
    expect(mockOnScoreChange).toHaveBeenCalledWith(expectedScore);
    iconSliderA = getIconSlider(listItems[0]);
    expect(iconSliderA.classList.toString()).toMatch(/red/i);
    expect(iconSliderA.classList.toString()).not.toMatch(/green|amber/i);

    // 3. Click item B: 'amber' -> 'green'. States: ['red', 'green']
    fireEvent.click(listItems[1]);
    expectedStates = ['red', 'green'];
    expectedScore = calcScore(expectedStates); // (0+100)/2 = 50
    expect(mockOnScoreChange).toHaveBeenCalledWith(expectedScore);
    iconSliderB = getIconSlider(listItems[1]);
    expect(iconSliderB.classList.toString()).toMatch(/green/i);
    expect(iconSliderB.classList.toString()).not.toMatch(/amber|red/i);


    // 4. Click item A again: 'red' -> 'amber'. States: ['amber', 'green']
    fireEvent.click(listItems[0]);
    expectedStates = ['amber', 'green'];
    expectedScore = calcScore(expectedStates); // (50+100)/2 = 75
    expect(mockOnScoreChange).toHaveBeenCalledWith(expectedScore);
    iconSliderA = getIconSlider(listItems[0]);
    expect(iconSliderA.classList.toString()).toMatch(/amber/i);
    expect(iconSliderA.classList.toString()).not.toMatch(/green|red/i);
  });

  it('calls onScoreChange prop correctly over multiple clicks', () => {
    const mockItems = ['item X', 'item Y']; // Using 2 items for simplicity
    const mockOnScoreChange = jest.fn();
    // Initial states: ['amber', 'amber'], Score: (50+50)/2 = 50
    const initialExpectedScore = calcScore(['amber', 'amber']);

    render(
      <SignalList
        items={mockItems}
        onScoreChange={mockOnScoreChange}
        title={mockTitle}
        description={mockDescription}
      />
    );
    // Called on mount
    expect(mockOnScoreChange).toHaveBeenCalledWith(initialExpectedScore);
    let timesCalled = 1;

    const listItems = screen.getAllByRole('listitem');

    // Click item X: 'amber' -> 'green'. States: ['green', 'amber']. Score: (100+50)/2 = 75
    fireEvent.click(listItems[0]);
    timesCalled++;
    expect(mockOnScoreChange).toHaveBeenCalledTimes(timesCalled);
    expect(mockOnScoreChange).toHaveBeenLastCalledWith(calcScore(['green', 'amber']));

    // Click item Y: 'amber' -> 'green'. States: ['green', 'green']. Score: (100+100)/2 = 100
    fireEvent.click(listItems[1]);
    timesCalled++;
    expect(mockOnScoreChange).toHaveBeenCalledTimes(timesCalled);
    expect(mockOnScoreChange).toHaveBeenLastCalledWith(calcScore(['green', 'green']));

    // Click item X again: 'green' -> 'red'. States: ['red', 'green']. Score: (0+100)/2 = 50
    fireEvent.click(listItems[0]);
    timesCalled++;
    expect(mockOnScoreChange).toHaveBeenCalledTimes(timesCalled);
    expect(mockOnScoreChange).toHaveBeenLastCalledWith(calcScore(['red', 'green']));

    // Click item Y again: 'green' -> 'red'. States: ['red', 'red']. Score: (0+0)/2 = 0
    fireEvent.click(listItems[1]);
    timesCalled++;
    expect(mockOnScoreChange).toHaveBeenCalledTimes(timesCalled);
    expect(mockOnScoreChange).toHaveBeenLastCalledWith(calcScore(['red', 'red']));

    // Click item X again: 'red' -> 'amber'. States: ['amber', 'red']. Score: (50+0)/2 = 25
    fireEvent.click(listItems[0]);
    timesCalled++;
    expect(mockOnScoreChange).toHaveBeenCalledTimes(timesCalled);
    expect(mockOnScoreChange).toHaveBeenLastCalledWith(calcScore(['amber', 'red']));
  });
});
